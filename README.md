
[](doc/Cima_da_Conegliano_God_the_Father.jpg)

# maker

## The basic idea

It is always better to separate the 'what' from the 'how', it is better to put
dependency as a value rather than a dependency as another function call.

So, instead of 

```clojure
(defn a [,,]
   ,,)

(defn b [,,]
  ,,(a ,,),,)

(defn c [,,]
  ,,(b,,),,)

```
we should try to force something like this
```clojure

(defn a* []
  ,,)

(defn b* [a]
  ,,a ,,)

(defn c* [,,]
  (let [a (a*)
        b (b* a)]
    ,,b,,))
```
In the former `b` depends on function `a` function. If `a` needs a new parameter
then `b` needs too. Let's imagine this is much deeper call stack, any change in
the bottom causes catastrophic escalation. Even worse when you realize that you
want to make the computation in `a`asynchronous. Not so when you defer this
dependency up to higher level, to c* in our case.

We are not programming this way because the potentially big `let` is rather
inconvenient to write, an anti-pattern. But wait, the big `let` could be
generated by a macro, just by following the name of the parameters, like in c2*!
```clojure
(defn c2* [,,]
  ,,(make b),,)
```

The transformation from a-b-c to a*-b*-c2* is not sufficient or possible all the
time but maker has some tricks which can increase the number of use cases.

Using this library you will have more independent and more pure functions, less
global variables in your system. With some helper functions you can make your
own simple reloaded/component support (for more information
search for 'reloaded' in `core-test`).

## What is the problem again?

[Watch this](https://youtu.be/Z6oVuYmRgkk?t=9m54s). A bit
different domain and a different solution but he is speaking about the same
issue in the next 3 minutes.

## maker is

  * still experimental! do not be fooled by the major version number
    * pls help to improve, give feedback
  * influenced by
    * dependency injection frameworks
    * goal oriented programming
    * declarative programming
    * build tools
    * data flow programming
    * value-level programming
    * transducers
  * small
  * old ideas implemented on top of Clojure
  * ideal for complex data transformations

## Features

* dependency tracking by looking for functions based on the names of parameters,
* works across namespaces,
* asynchronous goals, parallel execution,
* implicit dependency list

## Future options
* adoption in ClojureScript
* optional static types or specs
  * another huge win: we need specify only the result, the params are already
  have done.

## Usage, learn
```clj
[maker "2.0.0"]
```
To learn [check out](test/maker/core_test.clj) and play with the didactic tests.

## License

Copyright © 2015-2016 Tamás Jung

Distributed under the MIT License.
